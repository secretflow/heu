# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022 Ant Group Co., Ltd
# This file is distributed under the same license as the HEU package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: HEU \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-06 20:43+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../getting_started/algo_choice.rst:2
msgid "算法选择"
msgstr ""

#: ../../getting_started/algo_choice.rst:4
msgid "HEU 提供了多种 PHE 算法，本文档描述每种算法的特性，有助于您选择合适的算法。"
msgstr ""

#: ../../getting_started/algo_choice.rst:7
msgid "初始化 HEU 时需要指定 SchemaType 参数，例如："
msgstr ""

#: ../../getting_started/algo_choice.rst:14
msgid "本文档指示如何选择 phe.SchemaType 参数。"
msgstr ""

#: ../../getting_started/algo_choice.rst:18
msgid "算法总览"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
#: ../../getting_started/algo_choice.rst:23
msgid "SchemaType"
msgstr ""

#: ../../getting_started/algo_choice.rst:24
msgid "算法族"
msgstr ""

#: ../../getting_started/algo_choice.rst:25
msgid "简要描述"
msgstr ""

#: ../../getting_started/algo_choice.rst:26
msgid "推荐指数"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
#: ../../getting_started/algo_choice.rst:27
msgid "ZPaillier"
msgstr ""

#: ../../getting_started/algo_choice.rst:28
#: ../../getting_started/algo_choice.rst:32
#: ../../getting_started/algo_choice.rst:36
#: ../../getting_started/algo_choice.rst:56
#: ../../getting_started/algo_choice.rst:155
#: ../../getting_started/algo_choice.rst:181
#: ../../getting_started/algo_choice.rst:228
msgid "Paillier"
msgstr ""

#: ../../getting_started/algo_choice.rst:29
msgid "高度优化的 Paillier 算法，适合在所有平台下使用"
msgstr ""

#: ../../getting_started/algo_choice.rst:30
#: ../../getting_started/algo_choice.rst:42
msgid "★★★★★"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
#: ../../getting_started/algo_choice.rst:31
msgid "FPaillier"
msgstr ""

#: ../../getting_started/algo_choice.rst:33
msgid "性能很低，推荐用 ZPaillier 代替"
msgstr ""

#: ../../getting_started/algo_choice.rst:34
#: ../../getting_started/algo_choice.rst:46
msgid "★"
msgstr ""

#: ../../getting_started/algo_choice.rst:35
msgid "IPCL"
msgstr ""

#: ../../getting_started/algo_choice.rst:37
msgid "Intel 贡献的 Paillier 实现，支持 AVX512-IFMA 指令集和 Intel QAT 硬件加速，目前还在逐步完善中"
msgstr ""

#: ../../getting_started/algo_choice.rst:38
msgid "★★★"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
#: ../../getting_started/algo_choice.rst:39
msgid "OU"
msgstr ""

#: ../../getting_started/algo_choice.rst:40
#: ../../getting_started/algo_choice.rst:78
#: ../../getting_started/algo_choice.rst:253
msgid "Okamoto-Uchiyama"
msgstr ""

#: ../../getting_started/algo_choice.rst:41
msgid "功能与 Paillier 一致，且性能更高，密文膨胀度更低，但安全性略低，请见下文详细描述"
msgstr ""

#: ../../getting_started/algo_choice.rst:43
msgid "Mock"
msgstr ""

#: ../../getting_started/algo_choice.rst:44
msgid "None"
msgstr ""

#: ../../getting_started/algo_choice.rst:45
msgid "不加密，仅可用于测试或 Debug 目的，严谨在线上使用"
msgstr ""

#: ../../getting_started/algo_choice.rst:48
msgid "说明：推荐指数综合根据性能、安全性、适用面、稳定程度得出，并随着算法迭代升级动态变化。"
msgstr ""

#: ../../getting_started/algo_choice.rst:51
msgid "算法理论介绍"
msgstr ""

#: ../../getting_started/algo_choice.rst:53
msgid "本节介绍同态加密算法本身，与实现无关。"
msgstr ""

#: ../../getting_started/algo_choice.rst:58
msgid ""
"Paillier 算法由 Pascal Paillier 在 1999 年提出，参见：`算法详情 "
"<https://en.wikipedia.org/wiki/Paillier_cryptosystem>`__"
msgstr ""

#: ../../getting_started/algo_choice.rst:60
#: ../../getting_started/algo_choice.rst:82
msgid "Paillier 算法信息"
msgstr ""

#: ../../getting_started/algo_choice.rst:63
#: ../../getting_started/algo_choice.rst:85
msgid "项目"
msgstr ""

#: ../../getting_started/algo_choice.rst:64
#: ../../getting_started/algo_choice.rst:86
msgid "值"
msgstr ""

#: ../../getting_started/algo_choice.rst:65
#: ../../getting_started/algo_choice.rst:87
msgid "算法类型"
msgstr ""

#: ../../getting_started/algo_choice.rst:66
#: ../../getting_started/algo_choice.rst:88
msgid "加法同态加密"
msgstr ""

#: ../../getting_started/algo_choice.rst:67
#: ../../getting_started/algo_choice.rst:89
msgid "安全性"
msgstr ""

#: ../../getting_started/algo_choice.rst:68
#: ../../getting_started/algo_choice.rst:90
msgid "IND-CPA 安全，语义安全（Semantic Security）"
msgstr ""

#: ../../getting_started/algo_choice.rst:69
#: ../../getting_started/algo_choice.rst:91
msgid "困难假设"
msgstr ""

#: ../../getting_started/algo_choice.rst
msgid "复合剩余类的困难问题"
msgstr ""

#: ../../getting_started/algo_choice.rst
msgid "decisional composite residuosity assumption (DCRA)"
msgstr ""

#: ../../getting_started/algo_choice.rst:72
#: ../../getting_started/algo_choice.rst:94
msgid "安全强度（Security Strength）"
msgstr ""

#: ../../getting_started/algo_choice.rst
msgid "2048 位密钥长度等效 112 bits 安全强度"
msgstr ""

#: ../../getting_started/algo_choice.rst
msgid "3072 位密钥长度等效 128 bits 安全强度"
msgstr ""

#: ../../getting_started/algo_choice.rst:80
#, python-format
msgid ""
"Okamoto-Uchiyama 算法由 Tatsuaki Okamoto 和 Shigenori Uchiyama 在 1998 "
"年提出，参见：`算法详情 "
"<https://en.wikipedia.org/wiki/Okamoto%E2%80%93Uchiyama_cryptosystem>`__"
msgstr ""

#: ../../getting_started/algo_choice.rst
msgid "**p**-subgroup assumption"
msgstr ""

#: ../../getting_started/algo_choice.rst
msgid ""
"Detail: It is difficult to determine whether an element x in "
":math:`({\\mathbb Z}/n{\\mathbb Z})^{*}` is in the subgroup of order p"
msgstr ""

#: ../../getting_started/algo_choice.rst:100
msgid "OU 与 Paillier 比较"
msgstr ""

#: ../../getting_started/algo_choice.rst:102
msgid "OU 的优点："
msgstr ""

#: ../../getting_started/algo_choice.rst:104
msgid "相同的使用场景下，OU 的计算性能远高于 Paillier。"
msgstr ""

#: ../../getting_started/algo_choice.rst:105
msgid ""
"相同的使用场景下，OU 的密文大小只有 Paillier 的一半。假设密钥长度为 N，则 Paillier 的密文大小为 2N 比特，而 OU "
"密文为 N 比特。"
msgstr ""

#: ../../getting_started/algo_choice.rst:106
msgid "OU 的安全性与 Paillier 相同，两者都达到了 IND-CPA 安全，且都不满足 IND-CCA 安全。"
msgstr ""

#: ../../getting_started/algo_choice.rst:108
msgid "OU 的缺点："
msgstr ""

#: ../../getting_started/algo_choice.rst:110
msgid "OU 在学术上的知名度不如 Paillier。"
msgstr ""

#: ../../getting_started/algo_choice.rst:111
msgid ""
"OU 的明文值域空间不明确。假设密钥长度为 N，则 Paillier 的明文值域空间为 :math:`Z_N`，而 OU 的明文值域空间为 "
":math:`Z_p`，其中 p 是 private key 中的参数，因此 OU 的值域空间不是公开的。"
msgstr ""

#: ../../getting_started/algo_choice.rst:112
msgid "虽然理论上两者都不满足 IND-CCA 安全定义，但在实际 IND-CCA 场景下 OU 存在已知攻击，而 Paillier 暂未发现有效攻击。"
msgstr ""

#: ../../getting_started/algo_choice.rst:116
msgid "已知攻击"
msgstr ""

#: ../../getting_started/algo_choice.rst:118
msgid ""
"虽然 OU 与 Paillier 在学术上的安全级别相同，两者都满足 IND-CPA 安全，且都达不到 IND-CCA 安全，但实际在 IND-"
"CCA 场景下 OU 存在明文空间溢出攻击，而 Paillier 暂无有效攻击。"
msgstr ""

#: ../../getting_started/algo_choice.rst:121
msgid "OU 明文空间溢出攻击"
msgstr ""

#: ../../getting_started/algo_choice.rst:122
msgid ""
"OU 的明文空间为 :math:`Z_p`，即 OU 的密文解密以后存在 mod p 的效果。如果允许攻击者加密一个大于 p 的明文，则容易反推出"
" p，导致私钥泄漏，具体原理如下："
msgstr ""

#: ../../getting_started/algo_choice.rst:124
msgid "攻击者选择一个比 p 大的明文：:math:`m_1 > p`，进行加密，并且能够得到解密结果 :math:`m_2`。"
msgstr ""

#: ../../getting_started/algo_choice.rst:125
msgid "显然：:math:`m_1 > p, m_2 < p`，并且：:math:`m_1 \\equiv m_2 \\mod p`。"
msgstr ""

#: ../../getting_started/algo_choice.rst:126
msgid "通过计算最大公约数 :math:`gcd(m_1 - m_2, n)` 即可得到 p。"
msgstr ""

#: ../../getting_started/algo_choice.rst:128
msgid "OU 在实现时一般做了限制，不允许直接加密大于 p 的明文，但是由于 OU 支持密态加法和明密文乘法，上述溢出攻击仍旧是可能的："
msgstr ""

#: ../../getting_started/algo_choice.rst:130
msgid "攻击者选择一个接近但是小于 :math:`p` 的明文 m 加密得到 c"
msgstr ""

#: ../../getting_started/algo_choice.rst:131
msgid "对该密文 c 执行 t 次密文加法满足 :math:`m * t > p`，然后解密得到 :math:`m'`"
msgstr ""

#: ../../getting_started/algo_choice.rst:132
msgid "攻击者获取 :math:`m'`，利用同余关系即可获取私钥 :math:`p`"
msgstr ""

#: ../../getting_started/algo_choice.rst:135
msgid "OU 还可以使用吗"
msgstr ""

#: ../../getting_started/algo_choice.rst:137
msgid ""
"上述攻击成立的关键有两点，一是攻击者需要能构造出一个大于 p "
"的密文，二是攻击者需要能获取解密的结果，两者缺一不可，这是一个典型的选择密文攻击（CCA）场景，实际使用 OU 时，应当 **避免在 CCA "
"成立的场景下使用 OU**。"
msgstr ""

#: ../../getting_started/algo_choice.rst:139
msgid ""
"对于一些简单的场景，比如 Alice、Bob 两方计算，假设 Alice 有私钥，Bob 为恶意参与方，计算的过程为 Alice 将数据加密后发给"
" Bob 计算，Bob 把计算结果返回给 Alice，此时，即使 Bob 构造了恶意的密文 c，但是 Bob 拿不到 c 对应的解密结果，Bob "
"的攻击会造成计算错误，但是密钥不会泄露。"
msgstr ""

#: ../../getting_started/algo_choice.rst:141
msgid ""
"在一些复杂的隐私计算场景中，下一轮的交互取决于上一轮交互的结果，CCA 场景成立也许是不可避免的，但并非说明 OU 就一定无法使用，如果 "
"Alice 有有效的手段阻断攻击，OU 仍旧可以选用。让我们再来回顾一下攻击的过程：Bob 构造的密文 c 对应明文 m，Alice 解密后得到 "
":math:`m'=m \\mod p`，实际的问题是，:math:`m'` 有可能非常大，远超一般业务中使用的 int64 所能表达的范围，因为"
" Bob 想要构造一个 **略大于** p 的密文是非常困难的，p 一般非常大，key size 为 2048 时 p 大约为 "
"682bits，Bob 盲猜一个数 m 满足 :math:`m' < 2^{64}`，其概率小于 "
":math:`2^{-(682-64)}`，即盲猜的 m 的高 618bits 与 p exactly "
"same，这个概率是可以忽略不计的，因此可以认为 :math:`m'` 仍旧是一个大数，当 Alice 解密发现明文不在合理值域范围时，可以拒绝 "
"Bob 的结果，从而阻止 Bob 的攻击。"
msgstr ""

#: ../../getting_started/algo_choice.rst:145
msgid "算法实现介绍"
msgstr ""

#: ../../getting_started/algo_choice.rst:148
msgid "SchemaType.ZPaillier"
msgstr ""

#: ../../getting_started/algo_choice.rst:150
msgid ""
"ZPaillier 中的 Z 与数学中表示整数的 :math:`\\mathbb{Z}` 含义相同，即实现了一套支持整数运算的 Paillier "
"算法。"
msgstr ""

#: ../../getting_started/algo_choice.rst:152
msgid "ZPaillier 特性速查"
msgstr ""

#: ../../getting_started/algo_choice.rst:154
#: ../../getting_started/algo_choice.rst:180
#: ../../getting_started/algo_choice.rst:227
#: ../../getting_started/algo_choice.rst:252
msgid "实现算法"
msgstr ""

#: ../../getting_started/algo_choice.rst:156
#: ../../getting_started/algo_choice.rst:182
#: ../../getting_started/algo_choice.rst:229
#: ../../getting_started/algo_choice.rst:254
msgid "稳定性"
msgstr ""

#: ../../getting_started/algo_choice.rst:157
#: ../../getting_started/algo_choice.rst:183
#: ../../getting_started/algo_choice.rst:255
msgid "稳定"
msgstr ""

#: ../../getting_started/algo_choice.rst:158
#: ../../getting_started/algo_choice.rst:184
#: ../../getting_started/algo_choice.rst:231
#: ../../getting_started/algo_choice.rst:256
msgid "支持的平台"
msgstr ""

#: ../../getting_started/algo_choice.rst:159
#: ../../getting_started/algo_choice.rst:185
#: ../../getting_started/algo_choice.rst:257
msgid "Linux，macOS（Intel & Arm）"
msgstr ""

#: ../../getting_started/algo_choice.rst:160
#: ../../getting_started/algo_choice.rst:186
#: ../../getting_started/algo_choice.rst:233
#: ../../getting_started/algo_choice.rst:258
msgid "是否依赖特定硬件"
msgstr ""

#: ../../getting_started/algo_choice.rst:161
#: ../../getting_started/algo_choice.rst:187
#: ../../getting_started/algo_choice.rst:234
#: ../../getting_started/algo_choice.rst:259
msgid "不依赖"
msgstr ""

#: ../../getting_started/algo_choice.rst:162
#: ../../getting_started/algo_choice.rst:188
#: ../../getting_started/algo_choice.rst:235
#: ../../getting_started/algo_choice.rst:260
msgid "是否支持硬件加速"
msgstr ""

#: ../../getting_started/algo_choice.rst:163
#: ../../getting_started/algo_choice.rst:189
#: ../../getting_started/algo_choice.rst:261
msgid "不支持"
msgstr ""

#: ../../getting_started/algo_choice.rst:164
#: ../../getting_started/algo_choice.rst:190
#: ../../getting_started/algo_choice.rst:237
#: ../../getting_started/algo_choice.rst:262
msgid "相对性能"
msgstr ""

#: ../../getting_started/algo_choice.rst:165
#: ../../getting_started/algo_choice.rst:238
#: ../../getting_started/algo_choice.rst:263
msgid "高"
msgstr ""

#: ../../getting_started/algo_choice.rst:167
msgid ""
"HEU 对 ZPaillier 做了大量优化，ZPaillier 是一套性能较高的 Paillier "
"算法实现，且不依赖特定硬件，全平台使用，当您不知道如何选择算法时，可以默认使用 ZPaillier"
msgstr ""

#: ../../getting_started/algo_choice.rst:169
#: ../../getting_started/algo_choice.rst:266
msgid "实现基于的 Paper："
msgstr ""

#: ../../getting_started/algo_choice.rst:171
msgid ""
"Jurik, M. (2003). Extensions to the paillier cryptosystem with "
"applications to cryptological protocols. Brics, August. "
"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.4.2396&amp;rep=rep1&amp;type=pdf"
msgstr ""

#: ../../getting_started/algo_choice.rst:174
msgid "SchemaType.FPaillier"
msgstr ""

#: ../../getting_started/algo_choice.rst:176
msgid ""
"FPaillier 中的 F 表示浮点数 :math:`\\mathbb{F}`，Paillier 算法本身只支持整数，FPaillier "
"对Paillier 做了扩展，使其可以支持浮点数。"
msgstr ""

#: ../../getting_started/algo_choice.rst:178
msgid "FPaillier 特性速查"
msgstr ""

#: ../../getting_started/algo_choice.rst:191
msgid "低"
msgstr ""

#: ../../getting_started/algo_choice.rst:193
msgid ""
"FPaillier 的算法原理与 `Python-Paillier <https://github.com/data61/python-"
"paillier>`_ 库类似"
msgstr ""

#: ../../getting_started/algo_choice.rst:195
msgid ""
"FPaillier 支持浮点数的原理是将输入数据表示成 int_rep 形式：``scalar = int_rep * (BASE ** "
"exponent)``"
msgstr ""

#: ../../getting_started/algo_choice.rst:197
msgid "int_rep 和 exponent 计算示意"
msgstr ""

#: ../../getting_started/algo_choice.rst:209
msgid "**加密**"
msgstr ""

#: ../../getting_started/algo_choice.rst:211
msgid "Scalar 加密时只加密 int_rep 的值，exponent 明文存储，请注意安全风险。"
msgstr ""

#: ../../getting_started/algo_choice.rst:213
msgid "**同态运算**"
msgstr ""

#: ../../getting_started/algo_choice.rst:215
msgid ""
"先对齐 exponent，将 exponent 较大的数的 exponent 降低到较小的 exponent（new_exp），即 "
"``int_rep =  int_rep * (base**(exponent-new_exp))``，再执行同态运算。"
msgstr ""

#: ../../getting_started/algo_choice.rst:217
msgid ""
"FPaillier 的浮点数运算接口并没有在 Python 层暴露，在 Python 端 FPaillier 提供的接口与 ZPaillier "
"一致。若要使用 FPaillier 浮点功能，必须通过 C++ 接口调用，详细参考 `FPaillier 单测 "
"<https://github.com/secretflow/heu/blob/main/heu/library/algorithms/paillier_float/paillier_test.cc>`_"
msgstr ""

#: ../../getting_started/algo_choice.rst:221
msgid "SchemaType.IPCL"
msgstr ""

#: ../../getting_started/algo_choice.rst:223
msgid ""
"IPCL 全称 Intel Paillier Cryptosystem Library，是 Intel 贡献的一种 Paillier "
"算法实现，其特点是支持 AVX512-IFMA 指令集和 Intel QAT 硬件加速器加速。"
msgstr ""

#: ../../getting_started/algo_choice.rst:225
msgid "IPCL 特性速查"
msgstr ""

#: ../../getting_started/algo_choice.rst:230
msgid "实验性质，仅供测试和评估目的，还在持续完善中"
msgstr ""

#: ../../getting_started/algo_choice.rst:232
msgid "Linux，macOS（Intel）"
msgstr ""

#: ../../getting_started/algo_choice.rst:236
msgid "支持 AVX512-IFMA 指令集和/或 Intel QAT 加速器"
msgstr ""

#: ../../getting_started/algo_choice.rst:240
msgid "实现基于该代码库："
msgstr ""

#: ../../getting_started/algo_choice.rst:242
msgid "`pailliercryptolib <https://github.com/intel/pailliercryptolib>`_"
msgstr ""

#: ../../getting_started/algo_choice.rst:246
msgid "SchemaType.OU"
msgstr ""

#: ../../getting_started/algo_choice.rst:248
msgid ""
"OU 实现了 Okamoto-Uchiyama 算法，其功能与 ZPaillier 一致，且性能更高，很多时候可以成为 ZPaillier "
"的替代品，但 OU 存在一个已知攻击，详见 `Okamoto-Uchiyama`_ 算法理论介绍章节。"
msgstr ""

#: ../../getting_started/algo_choice.rst:250
msgid "OU 特性速查"
msgstr ""

#: ../../getting_started/algo_choice.rst:268
msgid ""
"Coron, J. S., Naccache, D., & Paillier, P. (1999). Accelerating Okamoto-"
"Uchiyama public-key cryptosystem. Electronics Letters, 35(4), 291–292. "
"https://doi.org/10.1049/el:19990229"
msgstr ""

#: ../../getting_started/algo_choice.rst:272
msgid "算法性能"
msgstr ""

#: ../../getting_started/algo_choice.rst:274
msgid ""
"HEU 提供了一个 Benchmark 用以测试每个算法的性能，若要运行 Benchmark 请先 clone HEU "
"代码库，然后在项目根目录下执行："
msgstr ""

#: ../../getting_started/algo_choice.rst:286
msgid "注：通过更换上述命令中的 schema 参数可以运行不同算法的 Benchmark。第一次运行 Benchmark 会自动触发代码编译。"
msgstr ""

#: ../../getting_started/algo_choice.rst:290
msgid "参考性能"
msgstr ""

#: ../../getting_started/algo_choice.rst:292
msgid "以下是部分算法的参考性能，不涉及加速硬件。配置参数："
msgstr ""

#: ../../getting_started/algo_choice.rst:294
msgid "CPU Intel(R) Xeon(R) Gold 5218 CPU @ 2.30GHz"
msgstr ""

#: ../../getting_started/algo_choice.rst:295
msgid "Key size = 2048"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "加密"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "密文+密文"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "密文+明文"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "密文*明文"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "解密"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "278"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "18.1"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "52.5"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "529"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "2458"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "8141"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "70.9"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "192"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "1960"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "86984"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "151187"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "230"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "150529"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "1692"
msgstr ""

#: ../../getting_started/algo_choice.rst:1
msgid "150580"
msgstr ""

#: ../../getting_started/algo_choice.rst:304
msgid "表格的项表示1万次操作的总时间，单位 ms。"
msgstr ""

